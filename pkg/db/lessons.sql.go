// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lessons.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countLessons = `-- name: CountLessons :one
SELECT COUNT(*) FROM "lessons"
WHERE "deleted_at" IS NULL
`

func (q *Queries) CountLessons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLessons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLessonsByCourse = `-- name: CountLessonsByCourse :one
SELECT COUNT(*) FROM "lessons"
WHERE "course_uuid" = $1 AND "deleted_at" IS NULL
`

func (q *Queries) CountLessonsByCourse(ctx context.Context, courseUuid uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLessonsByCourse, courseUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLesson = `-- name: CreateLesson :one
INSERT INTO "lessons" (
  "course_uuid", 
  "name", 
  "description",
  "order_index",
  "is_public"
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING uuid, created_at, modified_at, deleted_at, course_uuid, name, description, order_index, is_public
`

type CreateLessonParams struct {
	CourseUuid  uuid.UUID `json:"course_uuid"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	OrderIndex  int16     `json:"order_index"`
	IsPublic    bool      `json:"is_public"`
}

func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, createLesson,
		arg.CourseUuid,
		arg.Name,
		arg.Description,
		arg.OrderIndex,
		arg.IsPublic,
	)
	var i Lesson
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}

const deleteLesson = `-- name: DeleteLesson :exec
UPDATE "lessons"
SET "deleted_at" = NOW()
WHERE "uuid" = $1
`

func (q *Queries) DeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLesson, argUuid)
	return err
}

const getLesson = `-- name: GetLesson :one
SELECT uuid, created_at, modified_at, deleted_at, course_uuid, name, description, order_index, is_public FROM "lessons"
WHERE "uuid" = $1 AND "deleted_at" IS NULL 
LIMIT 1
`

func (q *Queries) GetLesson(ctx context.Context, argUuid uuid.UUID) (Lesson, error) {
	row := q.db.QueryRow(ctx, getLesson, argUuid)
	var i Lesson
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}

const hardDeleteLesson = `-- name: HardDeleteLesson :exec
DELETE FROM "lessons"
WHERE "uuid" = $1
`

func (q *Queries) HardDeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteLesson, argUuid)
	return err
}

const listLessons = `-- name: ListLessons :many
SELECT uuid, created_at, modified_at, deleted_at, course_uuid, name, description, order_index, is_public FROM "lessons"
WHERE "deleted_at" IS NULL
AND   ($3::uuid IS NULL OR "course_uuid" = $3)
ORDER BY "created_at" DESC
LIMIT $1 OFFSET $2
`

type ListLessonsParams struct {
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	CourseUuid *uuid.UUID `json:"course_uuid"`
}

func (q *Queries) ListLessons(ctx context.Context, arg ListLessonsParams) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, listLessons, arg.Limit, arg.Offset, arg.CourseUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lesson{}
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.CourseUuid,
			&i.Name,
			&i.Description,
			&i.OrderIndex,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const undeleteLesson = `-- name: UndeleteLesson :exec
UPDATE "lessons"
SET "deleted_at" = NULL
WHERE "uuid" = $1
`

func (q *Queries) UndeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, undeleteLesson, argUuid)
	return err
}

const updateLesson = `-- name: UpdateLesson :one
UPDATE "lessons"
SET "course_uuid" = COALESCE($2, "course_uuid"), 
    "name" = COALESCE($3, "name"), 
    "description" = COALESCE($4, "description"), 
    "order_index" = COALESCE($5, "order_index"),
    "is_public" = COALESCE($6, "is_public"),
    "modified_at" = NOW()
WHERE "uuid" = $1
RETURNING uuid, created_at, modified_at, deleted_at, course_uuid, name, description, order_index, is_public
`

type UpdateLessonParams struct {
	Uuid        uuid.UUID `json:"uuid"`
	CourseUuid  uuid.UUID `json:"course_uuid"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	OrderIndex  int16     `json:"order_index"`
	IsPublic    bool      `json:"is_public"`
}

func (q *Queries) UpdateLesson(ctx context.Context, arg UpdateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLesson,
		arg.Uuid,
		arg.CourseUuid,
		arg.Name,
		arg.Description,
		arg.OrderIndex,
		arg.IsPublic,
	)
	var i Lesson
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}
