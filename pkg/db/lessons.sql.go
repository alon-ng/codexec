// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lessons.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countLessons = `-- name: CountLessons :one
SELECT COUNT(*) FROM "lessons"
WHERE "deleted_at" IS NULL
`

func (q *Queries) CountLessons(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLessons)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLessonsByCourse = `-- name: CountLessonsByCourse :one
SELECT COUNT(*) FROM "lessons"
WHERE "course_uuid" = $1 AND "deleted_at" IS NULL
`

func (q *Queries) CountLessonsByCourse(ctx context.Context, courseUuid uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLessonsByCourse, courseUuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLesson = `-- name: CreateLesson :one
INSERT INTO "lessons" (
  "course_uuid", 
  "order_index",
  "is_public"
) VALUES (
  $1, $2, $3
)
RETURNING uuid, created_at, modified_at, deleted_at, course_uuid, order_index, is_public
`

type CreateLessonParams struct {
	CourseUuid uuid.UUID `json:"course_uuid"`
	OrderIndex int16     `json:"order_index"`
	IsPublic   bool      `json:"is_public"`
}

func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, createLesson, arg.CourseUuid, arg.OrderIndex, arg.IsPublic)
	var i Lesson
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}

const deleteLesson = `-- name: DeleteLesson :exec
UPDATE "lessons"
SET "deleted_at" = NOW()
WHERE "uuid" = $1
`

func (q *Queries) DeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLesson, argUuid)
	return err
}

const getLesson = `-- name: GetLesson :one
SELECT lessons.uuid, created_at, modified_at, deleted_at, course_uuid, order_index, is_public, lesson_translations.uuid, lesson_uuid, language, name, description FROM "lessons"
JOIN "lesson_translations" ON "lessons"."uuid" = "lesson_translations"."lesson_uuid" AND "lesson_translations"."language" = $2
WHERE "lessons"."uuid" = $1 AND "lessons"."deleted_at" IS NULL 
LIMIT 1
`

type GetLessonParams struct {
	Uuid     uuid.UUID `json:"uuid"`
	Language string    `json:"language"`
}

type GetLessonRow struct {
	Uuid        uuid.UUID  `json:"uuid"`
	CreatedAt   time.Time  `json:"created_at"`
	ModifiedAt  time.Time  `json:"modified_at"`
	DeletedAt   *time.Time `json:"deleted_at"`
	CourseUuid  uuid.UUID  `json:"course_uuid"`
	OrderIndex  int16      `json:"order_index"`
	IsPublic    bool       `json:"is_public"`
	Uuid_2      uuid.UUID  `json:"uuid_2"`
	LessonUuid  uuid.UUID  `json:"lesson_uuid"`
	Language    string     `json:"language"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
}

func (q *Queries) GetLesson(ctx context.Context, arg GetLessonParams) (GetLessonRow, error) {
	row := q.db.QueryRow(ctx, getLesson, arg.Uuid, arg.Language)
	var i GetLessonRow
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.OrderIndex,
		&i.IsPublic,
		&i.Uuid_2,
		&i.LessonUuid,
		&i.Language,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const hardDeleteLesson = `-- name: HardDeleteLesson :exec
DELETE FROM "lessons"
WHERE "uuid" = $1
`

func (q *Queries) HardDeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteLesson, argUuid)
	return err
}

const listLessons = `-- name: ListLessons :many
SELECT lessons.uuid, created_at, modified_at, deleted_at, course_uuid, order_index, is_public, lesson_translations.uuid, lesson_uuid, language, name, description FROM "lessons"
JOIN "lesson_translations" ON "lessons"."uuid" = "lesson_translations"."lesson_uuid" AND "lesson_translations"."language" = $3
WHERE "lessons"."deleted_at" IS NULL
AND   ($4::uuid IS NULL OR "course_uuid" = $4)
ORDER BY "created_at" DESC
LIMIT $1 OFFSET $2
`

type ListLessonsParams struct {
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	Language   string     `json:"language"`
	CourseUuid *uuid.UUID `json:"course_uuid"`
}

type ListLessonsRow struct {
	Uuid        uuid.UUID  `json:"uuid"`
	CreatedAt   time.Time  `json:"created_at"`
	ModifiedAt  time.Time  `json:"modified_at"`
	DeletedAt   *time.Time `json:"deleted_at"`
	CourseUuid  uuid.UUID  `json:"course_uuid"`
	OrderIndex  int16      `json:"order_index"`
	IsPublic    bool       `json:"is_public"`
	Uuid_2      uuid.UUID  `json:"uuid_2"`
	LessonUuid  uuid.UUID  `json:"lesson_uuid"`
	Language    string     `json:"language"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
}

func (q *Queries) ListLessons(ctx context.Context, arg ListLessonsParams) ([]ListLessonsRow, error) {
	rows, err := q.db.Query(ctx, listLessons,
		arg.Limit,
		arg.Offset,
		arg.Language,
		arg.CourseUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLessonsRow{}
	for rows.Next() {
		var i ListLessonsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.CourseUuid,
			&i.OrderIndex,
			&i.IsPublic,
			&i.Uuid_2,
			&i.LessonUuid,
			&i.Language,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const undeleteLesson = `-- name: UndeleteLesson :exec
UPDATE "lessons"
SET "deleted_at" = NULL
WHERE "uuid" = $1
`

func (q *Queries) UndeleteLesson(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, undeleteLesson, argUuid)
	return err
}

const updateLesson = `-- name: UpdateLesson :one
UPDATE "lessons"
SET "course_uuid" = COALESCE($2, "course_uuid"), 
    "order_index" = COALESCE($3, "order_index"),
    "is_public" = COALESCE($4, "is_public"),
    "modified_at" = NOW()
WHERE "uuid" = $1
RETURNING uuid, created_at, modified_at, deleted_at, course_uuid, order_index, is_public
`

type UpdateLessonParams struct {
	Uuid       uuid.UUID `json:"uuid"`
	CourseUuid uuid.UUID `json:"course_uuid"`
	OrderIndex int16     `json:"order_index"`
	IsPublic   bool      `json:"is_public"`
}

func (q *Queries) UpdateLesson(ctx context.Context, arg UpdateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLesson,
		arg.Uuid,
		arg.CourseUuid,
		arg.OrderIndex,
		arg.IsPublic,
	)
	var i Lesson
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.CourseUuid,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}
