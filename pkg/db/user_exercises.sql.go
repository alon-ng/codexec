// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_exercises.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createUserExercise = `-- name: CreateUserExercise :one
INSERT INTO "user_exercises" (
  "user_uuid", 
  "exercise_uuid", 
  "submission",
  "attempts",
  "completed_at"
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING uuid, started_at, last_accessed_at, user_uuid, exercise_uuid, submission, attempts, completed_at
`

type CreateUserExerciseParams struct {
	UserUuid     uuid.UUID       `json:"user_uuid"`
	ExerciseUuid uuid.UUID       `json:"exercise_uuid"`
	Submission   json.RawMessage `json:"submission"`
	Attempts     int32           `json:"attempts"`
	CompletedAt  *time.Time      `json:"completed_at"`
}

func (q *Queries) CreateUserExercise(ctx context.Context, arg CreateUserExerciseParams) (UserExercise, error) {
	row := q.db.QueryRow(ctx, createUserExercise,
		arg.UserUuid,
		arg.ExerciseUuid,
		arg.Submission,
		arg.Attempts,
		arg.CompletedAt,
	)
	var i UserExercise
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.ExerciseUuid,
		&i.Submission,
		&i.Attempts,
		&i.CompletedAt,
	)
	return i, err
}

const deleteUserExercise = `-- name: DeleteUserExercise :exec
DELETE FROM "user_exercises"
WHERE "uuid" = $1
`

func (q *Queries) DeleteUserExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserExercise, argUuid)
	return err
}

const getUserExercise = `-- name: GetUserExercise :one
SELECT uuid, started_at, last_accessed_at, user_uuid, exercise_uuid, submission, attempts, completed_at FROM "user_exercises"
WHERE "uuid" = $1
LIMIT 1
`

func (q *Queries) GetUserExercise(ctx context.Context, argUuid uuid.UUID) (UserExercise, error) {
	row := q.db.QueryRow(ctx, getUserExercise, argUuid)
	var i UserExercise
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.ExerciseUuid,
		&i.Submission,
		&i.Attempts,
		&i.CompletedAt,
	)
	return i, err
}

const getUserExerciseByUserAndExercise = `-- name: GetUserExerciseByUserAndExercise :one
SELECT uuid, started_at, last_accessed_at, user_uuid, exercise_uuid, submission, attempts, completed_at FROM "user_exercises"
WHERE "user_uuid" = $1 AND "exercise_uuid" = $2
LIMIT 1
`

type GetUserExerciseByUserAndExerciseParams struct {
	UserUuid     uuid.UUID `json:"user_uuid"`
	ExerciseUuid uuid.UUID `json:"exercise_uuid"`
}

func (q *Queries) GetUserExerciseByUserAndExercise(ctx context.Context, arg GetUserExerciseByUserAndExerciseParams) (UserExercise, error) {
	row := q.db.QueryRow(ctx, getUserExerciseByUserAndExercise, arg.UserUuid, arg.ExerciseUuid)
	var i UserExercise
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.ExerciseUuid,
		&i.Submission,
		&i.Attempts,
		&i.CompletedAt,
	)
	return i, err
}

const updateUserExercise = `-- name: UpdateUserExercise :one
UPDATE "user_exercises"
SET "user_uuid" = COALESCE($2, "user_uuid"), 
    "exercise_uuid" = COALESCE($3, "exercise_uuid"), 
    "submission" = COALESCE($4, "submission"),
    "attempts" = COALESCE($5, "attempts"),
    "completed_at" = COALESCE($6, "completed_at")
WHERE "uuid" = $1
RETURNING uuid, started_at, last_accessed_at, user_uuid, exercise_uuid, submission, attempts, completed_at
`

type UpdateUserExerciseParams struct {
	Uuid         uuid.UUID        `json:"uuid"`
	UserUuid     *uuid.UUID       `json:"user_uuid"`
	ExerciseUuid *uuid.UUID       `json:"exercise_uuid"`
	Submission   *json.RawMessage `json:"submission"`
	Attempts     *int32           `json:"attempts"`
	CompletedAt  *time.Time       `json:"completed_at"`
}

func (q *Queries) UpdateUserExercise(ctx context.Context, arg UpdateUserExerciseParams) (UserExercise, error) {
	row := q.db.QueryRow(ctx, updateUserExercise,
		arg.Uuid,
		arg.UserUuid,
		arg.ExerciseUuid,
		arg.Submission,
		arg.Attempts,
		arg.CompletedAt,
	)
	var i UserExercise
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.ExerciseUuid,
		&i.Submission,
		&i.Attempts,
		&i.CompletedAt,
	)
	return i, err
}
