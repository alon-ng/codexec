// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercises.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const countExercises = `-- name: CountExercises :one
SELECT COUNT(*) FROM "exercises"
WHERE "deleted_at" IS NULL
`

func (q *Queries) CountExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExercise = `-- name: CreateExercise :one
INSERT INTO "exercises" (
  "lesson_uuid", 
  "name", 
  "description",
  "order_index",
  "reward",
  "type",
  "data"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, name, description, order_index, reward, type, data
`

type CreateExerciseParams struct {
	LessonUuid  uuid.UUID       `json:"lesson_uuid"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	OrderIndex  int16           `json:"order_index"`
	Reward      int16           `json:"reward"`
	Type        ExerciseType    `json:"type"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.LessonUuid,
		arg.Name,
		arg.Description,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.Data,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.Data,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NOW()
WHERE "uuid" = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExercise, argUuid)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT uuid, created_at, modified_at, deleted_at, lesson_uuid, name, description, order_index, reward, type, data FROM "exercises"
WHERE "uuid" = $1 AND "deleted_at" IS NULL 
LIMIT 1
`

func (q *Queries) GetExercise(ctx context.Context, argUuid uuid.UUID) (Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, argUuid)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.Data,
	)
	return i, err
}

const hardDeleteExercise = `-- name: HardDeleteExercise :exec
DELETE FROM "exercises"
WHERE "uuid" = $1
`

func (q *Queries) HardDeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteExercise, argUuid)
	return err
}

const listExercises = `-- name: ListExercises :many
SELECT uuid, created_at, modified_at, deleted_at, lesson_uuid, name, description, order_index, reward, type, data FROM "exercises"
WHERE "deleted_at" IS NULL
AND   ($3::uuid IS NULL OR "lesson_uuid" = $3)
ORDER BY "created_at" DESC
LIMIT $1 OFFSET $2
`

type ListExercisesParams struct {
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	LessonUuid *uuid.UUID `json:"lesson_uuid"`
}

func (q *Queries) ListExercises(ctx context.Context, arg ListExercisesParams) ([]Exercise, error) {
	rows, err := q.db.Query(ctx, listExercises, arg.Limit, arg.Offset, arg.LessonUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Exercise{}
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.LessonUuid,
			&i.Name,
			&i.Description,
			&i.OrderIndex,
			&i.Reward,
			&i.Type,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const undeleteExercise = `-- name: UndeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NULL
WHERE "uuid" = $1
`

func (q *Queries) UndeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, undeleteExercise, argUuid)
	return err
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE "exercises"
SET "lesson_uuid" = COALESCE($2, "lesson_uuid"), 
    "name" = COALESCE($3, "name"), 
    "description" = COALESCE($4, "description"), 
    "order_index" = COALESCE($5, "order_index"),
    "reward" = COALESCE($6, "reward"),
    "type" = COALESCE($7, "type"),
    "data" = COALESCE($8, "data"),
    "modified_at" = NOW()
WHERE "uuid" = $1
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, name, description, order_index, reward, type, data
`

type UpdateExerciseParams struct {
	Uuid        uuid.UUID       `json:"uuid"`
	LessonUuid  uuid.UUID       `json:"lesson_uuid"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	OrderIndex  int16           `json:"order_index"`
	Reward      int16           `json:"reward"`
	Type        ExerciseType    `json:"type"`
	Data        json.RawMessage `json:"data"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.Uuid,
		arg.LessonUuid,
		arg.Name,
		arg.Description,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.Data,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.Name,
		&i.Description,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.Data,
	)
	return i, err
}
