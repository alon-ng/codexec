// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercises.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const countExercises = `-- name: CountExercises :one
SELECT COUNT(*) FROM "exercises"
WHERE "deleted_at" IS NULL
`

func (q *Queries) CountExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExercise = `-- name: CreateExercise :one
INSERT INTO "exercises" (
  "lesson_uuid", 
  "order_index",
  "reward",
  "type",
  "code_data",
  "quiz_data"
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, code_data, quiz_data
`

type CreateExerciseParams struct {
	LessonUuid uuid.UUID        `json:"lesson_uuid"`
	OrderIndex int16            `json:"order_index"`
	Reward     int16            `json:"reward"`
	Type       ExerciseType     `json:"type"`
	CodeData   *json.RawMessage `json:"code_data"`
	QuizData   *json.RawMessage `json:"quiz_data"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.LessonUuid,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.CodeData,
		arg.QuizData,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NOW()
WHERE "uuid" = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExercise, argUuid)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, exercises.code_data, exercises.quiz_data, exercise_translations.uuid, exercise_uuid, language, name, description, exercise_translations.code_data, exercise_translations.quiz_data FROM "exercises"
JOIN "exercise_translations" ON "exercises"."uuid" = "exercise_translations"."exercise_uuid" AND "exercise_translations"."language" = $2
WHERE "exercises"."uuid" = $1 AND "exercises"."deleted_at" IS NULL 
LIMIT 1
`

type GetExerciseParams struct {
	Uuid     uuid.UUID `json:"uuid"`
	Language string    `json:"language"`
}

type GetExerciseRow struct {
	Uuid         uuid.UUID        `json:"uuid"`
	CreatedAt    time.Time        `json:"created_at"`
	ModifiedAt   time.Time        `json:"modified_at"`
	DeletedAt    *time.Time       `json:"deleted_at"`
	LessonUuid   uuid.UUID        `json:"lesson_uuid"`
	OrderIndex   int16            `json:"order_index"`
	Reward       int16            `json:"reward"`
	Type         ExerciseType     `json:"type"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
	Uuid_2       uuid.UUID        `json:"uuid_2"`
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData_2   *json.RawMessage `json:"code_data_2"`
	QuizData_2   *json.RawMessage `json:"quiz_data_2"`
}

func (q *Queries) GetExercise(ctx context.Context, arg GetExerciseParams) (GetExerciseRow, error) {
	row := q.db.QueryRow(ctx, getExercise, arg.Uuid, arg.Language)
	var i GetExerciseRow
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
		&i.Uuid_2,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.CodeData_2,
		&i.QuizData_2,
	)
	return i, err
}

const hardDeleteExercise = `-- name: HardDeleteExercise :exec
DELETE FROM "exercises"
WHERE "uuid" = $1
`

func (q *Queries) HardDeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteExercise, argUuid)
	return err
}

const listExercises = `-- name: ListExercises :many
SELECT exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, exercises.code_data, exercises.quiz_data, exercise_translations.uuid, exercise_uuid, language, name, description, exercise_translations.code_data, exercise_translations.quiz_data FROM "exercises"
JOIN "exercise_translations" ON "exercises"."uuid" = "exercise_translations"."exercise_uuid" AND "exercise_translations"."language" = $3
WHERE "exercises"."deleted_at" IS NULL
AND   ($4::uuid IS NULL OR "lesson_uuid" = $4)
ORDER BY "created_at" DESC
LIMIT $1 OFFSET $2
`

type ListExercisesParams struct {
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	Language   string     `json:"language"`
	LessonUuid *uuid.UUID `json:"lesson_uuid"`
}

type ListExercisesRow struct {
	Uuid         uuid.UUID        `json:"uuid"`
	CreatedAt    time.Time        `json:"created_at"`
	ModifiedAt   time.Time        `json:"modified_at"`
	DeletedAt    *time.Time       `json:"deleted_at"`
	LessonUuid   uuid.UUID        `json:"lesson_uuid"`
	OrderIndex   int16            `json:"order_index"`
	Reward       int16            `json:"reward"`
	Type         ExerciseType     `json:"type"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
	Uuid_2       uuid.UUID        `json:"uuid_2"`
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData_2   *json.RawMessage `json:"code_data_2"`
	QuizData_2   *json.RawMessage `json:"quiz_data_2"`
}

func (q *Queries) ListExercises(ctx context.Context, arg ListExercisesParams) ([]ListExercisesRow, error) {
	rows, err := q.db.Query(ctx, listExercises,
		arg.Limit,
		arg.Offset,
		arg.Language,
		arg.LessonUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExercisesRow{}
	for rows.Next() {
		var i ListExercisesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.LessonUuid,
			&i.OrderIndex,
			&i.Reward,
			&i.Type,
			&i.CodeData,
			&i.QuizData,
			&i.Uuid_2,
			&i.ExerciseUuid,
			&i.Language,
			&i.Name,
			&i.Description,
			&i.CodeData_2,
			&i.QuizData_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const undeleteExercise = `-- name: UndeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NULL
WHERE "uuid" = $1
`

func (q *Queries) UndeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, undeleteExercise, argUuid)
	return err
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE "exercises"
SET "order_index" = COALESCE($2, "order_index"),
    "reward" = COALESCE($3, "reward"),
    "type" = COALESCE($4, "type"),
    "code_data" = COALESCE($5, "code_data"),
    "quiz_data" = COALESCE($6, "quiz_data"),
    "modified_at" = NOW()
WHERE "uuid" = $1
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, code_data, quiz_data
`

type UpdateExerciseParams struct {
	Uuid       uuid.UUID        `json:"uuid"`
	OrderIndex *int16           `json:"order_index"`
	Reward     *int16           `json:"reward"`
	Type       *ExerciseType    `json:"type"`
	CodeData   *json.RawMessage `json:"code_data"`
	QuizData   *json.RawMessage `json:"quiz_data"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.Uuid,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.CodeData,
		arg.QuizData,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
	)
	return i, err
}
