// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercises.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const countExercises = `-- name: CountExercises :one
SELECT COUNT(*) FROM "exercises"
WHERE "deleted_at" IS NULL
`

func (q *Queries) CountExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExercise = `-- name: CreateExercise :one
INSERT INTO "exercises" (
  "lesson_uuid", 
  "order_index",
  "reward",
  "type",
  "code_data",
  "quiz_data",
  "io_checker",
  "code_checker"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, code_data, quiz_data, io_checker, code_checker
`

type CreateExerciseParams struct {
	LessonUuid  uuid.UUID        `json:"lesson_uuid"`
	OrderIndex  int16            `json:"order_index"`
	Reward      int16            `json:"reward"`
	Type        ExerciseType     `json:"type"`
	CodeData    *json.RawMessage `json:"code_data"`
	QuizData    *json.RawMessage `json:"quiz_data"`
	IoChecker   *json.RawMessage `json:"io_checker"`
	CodeChecker *json.RawMessage `json:"code_checker"`
}

func (q *Queries) CreateExercise(ctx context.Context, arg CreateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.LessonUuid,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.CodeData,
		arg.QuizData,
		arg.IoChecker,
		arg.CodeChecker,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
		&i.IoChecker,
		&i.CodeChecker,
	)
	return i, err
}

const deleteExercise = `-- name: DeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NOW()
WHERE "uuid" = $1
`

func (q *Queries) DeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExercise, argUuid)
	return err
}

const getExercise = `-- name: GetExercise :one
SELECT exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, exercises.code_data, exercises.quiz_data, io_checker, code_checker, exercise_translations.uuid, exercise_uuid, language, name, description, exercise_translations.code_data, exercise_translations.quiz_data FROM "exercises"
JOIN "exercise_translations" ON "exercises"."uuid" = "exercise_translations"."exercise_uuid" AND "exercise_translations"."language" = $2
WHERE "exercises"."uuid" = $1 AND "exercises"."deleted_at" IS NULL 
LIMIT 1
`

type GetExerciseParams struct {
	Uuid     uuid.UUID `json:"uuid"`
	Language string    `json:"language"`
}

type GetExerciseRow struct {
	Uuid         uuid.UUID        `json:"uuid"`
	CreatedAt    time.Time        `json:"created_at"`
	ModifiedAt   time.Time        `json:"modified_at"`
	DeletedAt    *time.Time       `json:"deleted_at"`
	LessonUuid   uuid.UUID        `json:"lesson_uuid"`
	OrderIndex   int16            `json:"order_index"`
	Reward       int16            `json:"reward"`
	Type         ExerciseType     `json:"type"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
	IoChecker    *json.RawMessage `json:"io_checker"`
	CodeChecker  *json.RawMessage `json:"code_checker"`
	Uuid_2       uuid.UUID        `json:"uuid_2"`
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData_2   *json.RawMessage `json:"code_data_2"`
	QuizData_2   *json.RawMessage `json:"quiz_data_2"`
}

func (q *Queries) GetExercise(ctx context.Context, arg GetExerciseParams) (GetExerciseRow, error) {
	row := q.db.QueryRow(ctx, getExercise, arg.Uuid, arg.Language)
	var i GetExerciseRow
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
		&i.IoChecker,
		&i.CodeChecker,
		&i.Uuid_2,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.CodeData_2,
		&i.QuizData_2,
	)
	return i, err
}

const getExerciseForSubmission = `-- name: GetExerciseForSubmission :one
SELECT "courses"."subject", "exercises"."type", "exercises"."code_checker", "exercises"."io_checker" FROM "courses"
JOIN "lessons" ON "courses"."uuid" = "lessons"."course_uuid"
JOIN "exercises" ON "lessons"."uuid" = "exercises"."lesson_uuid"
WHERE "exercises"."uuid" = $1
LIMIT 1
`

type GetExerciseForSubmissionRow struct {
	Subject     string           `json:"subject"`
	Type        ExerciseType     `json:"type"`
	CodeChecker *json.RawMessage `json:"code_checker"`
	IoChecker   *json.RawMessage `json:"io_checker"`
}

func (q *Queries) GetExerciseForSubmission(ctx context.Context, argUuid uuid.UUID) (GetExerciseForSubmissionRow, error) {
	row := q.db.QueryRow(ctx, getExerciseForSubmission, argUuid)
	var i GetExerciseForSubmissionRow
	err := row.Scan(
		&i.Subject,
		&i.Type,
		&i.CodeChecker,
		&i.IoChecker,
	)
	return i, err
}

const getExerciseLessonCourse = `-- name: GetExerciseLessonCourse :one
SELECT courses.uuid, courses.created_at, courses.modified_at, courses.deleted_at, courses.subject, courses.price, courses.discount, courses.is_active, courses.difficulty, lessons.uuid, lessons.created_at, lessons.modified_at, lessons.deleted_at, lessons.course_uuid, lessons.order_index, lessons.is_public FROM "courses"
JOIN "lessons" ON "courses"."uuid" = "lessons"."course_uuid"
JOIN "exercises" ON "lessons"."uuid" = "exercises"."lesson_uuid"
WHERE "exercises"."uuid" = $1
LIMIT 1
`

type GetExerciseLessonCourseRow struct {
	Uuid         uuid.UUID  `json:"uuid"`
	CreatedAt    time.Time  `json:"created_at"`
	ModifiedAt   time.Time  `json:"modified_at"`
	DeletedAt    *time.Time `json:"deleted_at"`
	Subject      string     `json:"subject"`
	Price        int16      `json:"price"`
	Discount     int16      `json:"discount"`
	IsActive     bool       `json:"is_active"`
	Difficulty   int16      `json:"difficulty"`
	Uuid_2       uuid.UUID  `json:"uuid_2"`
	CreatedAt_2  time.Time  `json:"created_at_2"`
	ModifiedAt_2 time.Time  `json:"modified_at_2"`
	DeletedAt_2  *time.Time `json:"deleted_at_2"`
	CourseUuid   uuid.UUID  `json:"course_uuid"`
	OrderIndex   int16      `json:"order_index"`
	IsPublic     bool       `json:"is_public"`
}

func (q *Queries) GetExerciseLessonCourse(ctx context.Context, argUuid uuid.UUID) (GetExerciseLessonCourseRow, error) {
	row := q.db.QueryRow(ctx, getExerciseLessonCourse, argUuid)
	var i GetExerciseLessonCourseRow
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.Subject,
		&i.Price,
		&i.Discount,
		&i.IsActive,
		&i.Difficulty,
		&i.Uuid_2,
		&i.CreatedAt_2,
		&i.ModifiedAt_2,
		&i.DeletedAt_2,
		&i.CourseUuid,
		&i.OrderIndex,
		&i.IsPublic,
	)
	return i, err
}

const hardDeleteExercise = `-- name: HardDeleteExercise :exec
DELETE FROM "exercises"
WHERE "uuid" = $1
`

func (q *Queries) HardDeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteExercise, argUuid)
	return err
}

const listExercises = `-- name: ListExercises :many
SELECT exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, exercises.code_data, exercises.quiz_data, io_checker, code_checker, exercise_translations.uuid, exercise_uuid, language, name, description, exercise_translations.code_data, exercise_translations.quiz_data FROM "exercises"
JOIN "exercise_translations" ON "exercises"."uuid" = "exercise_translations"."exercise_uuid" AND "exercise_translations"."language" = $3
WHERE "exercises"."deleted_at" IS NULL
AND   ($4::uuid IS NULL OR "lesson_uuid" = $4)
ORDER BY "created_at" DESC
LIMIT $1 OFFSET $2
`

type ListExercisesParams struct {
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	Language   string     `json:"language"`
	LessonUuid *uuid.UUID `json:"lesson_uuid"`
}

type ListExercisesRow struct {
	Uuid         uuid.UUID        `json:"uuid"`
	CreatedAt    time.Time        `json:"created_at"`
	ModifiedAt   time.Time        `json:"modified_at"`
	DeletedAt    *time.Time       `json:"deleted_at"`
	LessonUuid   uuid.UUID        `json:"lesson_uuid"`
	OrderIndex   int16            `json:"order_index"`
	Reward       int16            `json:"reward"`
	Type         ExerciseType     `json:"type"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
	IoChecker    *json.RawMessage `json:"io_checker"`
	CodeChecker  *json.RawMessage `json:"code_checker"`
	Uuid_2       uuid.UUID        `json:"uuid_2"`
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData_2   *json.RawMessage `json:"code_data_2"`
	QuizData_2   *json.RawMessage `json:"quiz_data_2"`
}

func (q *Queries) ListExercises(ctx context.Context, arg ListExercisesParams) ([]ListExercisesRow, error) {
	rows, err := q.db.Query(ctx, listExercises,
		arg.Limit,
		arg.Offset,
		arg.Language,
		arg.LessonUuid,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExercisesRow{}
	for rows.Next() {
		var i ListExercisesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.DeletedAt,
			&i.LessonUuid,
			&i.OrderIndex,
			&i.Reward,
			&i.Type,
			&i.CodeData,
			&i.QuizData,
			&i.IoChecker,
			&i.CodeChecker,
			&i.Uuid_2,
			&i.ExerciseUuid,
			&i.Language,
			&i.Name,
			&i.Description,
			&i.CodeData_2,
			&i.QuizData_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const undeleteExercise = `-- name: UndeleteExercise :exec
UPDATE "exercises"
SET "deleted_at" = NULL
WHERE "uuid" = $1
`

func (q *Queries) UndeleteExercise(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, undeleteExercise, argUuid)
	return err
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE "exercises"
SET "order_index" = COALESCE($2, "order_index"),
    "reward" = COALESCE($3, "reward"),
    "type" = COALESCE($4, "type"),
    "code_data" = COALESCE($5, "code_data"),
    "quiz_data" = COALESCE($6, "quiz_data"),
    "io_checker" = COALESCE($7, "io_checker"),
    "code_checker" = COALESCE($8, "code_checker"),
    "modified_at" = NOW()
WHERE "uuid" = $1
RETURNING uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, code_data, quiz_data, io_checker, code_checker
`

type UpdateExerciseParams struct {
	Uuid        uuid.UUID        `json:"uuid"`
	OrderIndex  *int16           `json:"order_index"`
	Reward      *int16           `json:"reward"`
	Type        *ExerciseType    `json:"type"`
	CodeData    *json.RawMessage `json:"code_data"`
	QuizData    *json.RawMessage `json:"quiz_data"`
	IoChecker   *json.RawMessage `json:"io_checker"`
	CodeChecker *json.RawMessage `json:"code_checker"`
}

func (q *Queries) UpdateExercise(ctx context.Context, arg UpdateExerciseParams) (Exercise, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.Uuid,
		arg.OrderIndex,
		arg.Reward,
		arg.Type,
		arg.CodeData,
		arg.QuizData,
		arg.IoChecker,
		arg.CodeChecker,
	)
	var i Exercise
	err := row.Scan(
		&i.Uuid,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData,
		&i.QuizData,
		&i.IoChecker,
		&i.CodeChecker,
	)
	return i, err
}
