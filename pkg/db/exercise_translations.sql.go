// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercise_translations.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createExerciseTranslation = `-- name: CreateExerciseTranslation :one
INSERT INTO "exercise_translations" (
  "exercise_uuid",
  "language",
  "name",
  "description"
) VALUES (
  $1, $2, $3, $4
)
RETURNING uuid, exercise_uuid, language, name, description
`

type CreateExerciseTranslationParams struct {
	ExerciseUuid uuid.UUID `json:"exercise_uuid"`
	Language     string    `json:"language"`
	Name         string    `json:"name"`
	Description  string    `json:"description"`
}

func (q *Queries) CreateExerciseTranslation(ctx context.Context, arg CreateExerciseTranslationParams) (ExerciseTranslation, error) {
	row := q.db.QueryRow(ctx, createExerciseTranslation,
		arg.ExerciseUuid,
		arg.Language,
		arg.Name,
		arg.Description,
	)
	var i ExerciseTranslation
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const deleteExerciseTranslation = `-- name: DeleteExerciseTranslation :exec
DELETE FROM "exercise_translations"
USING "exercises"
WHERE "exercise_translations"."exercise_uuid" = "exercises"."uuid"
AND "exercises"."uuid" = $1
`

func (q *Queries) DeleteExerciseTranslation(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExerciseTranslation, argUuid)
	return err
}

const getExerciseTranslation = `-- name: GetExerciseTranslation :one
SELECT exercise_translations.uuid, exercise_uuid, language, name, description, exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, data FROM "exercise_translations"
JOIN "exercises" ON "exercise_translations"."exercise_uuid" = "exercises"."uuid"
WHERE "exercise_translations"."uuid" = $1
AND "exercises"."deleted_at" IS NULL
LIMIT 1
`

type GetExerciseTranslationRow struct {
	Uuid         uuid.UUID       `json:"uuid"`
	ExerciseUuid uuid.UUID       `json:"exercise_uuid"`
	Language     string          `json:"language"`
	Name         string          `json:"name"`
	Description  string          `json:"description"`
	Uuid_2       uuid.UUID       `json:"uuid_2"`
	CreatedAt    time.Time       `json:"created_at"`
	ModifiedAt   time.Time       `json:"modified_at"`
	DeletedAt    *time.Time      `json:"deleted_at"`
	LessonUuid   uuid.UUID       `json:"lesson_uuid"`
	OrderIndex   int16           `json:"order_index"`
	Reward       int16           `json:"reward"`
	Type         ExerciseType    `json:"type"`
	Data         json.RawMessage `json:"data"`
}

func (q *Queries) GetExerciseTranslation(ctx context.Context, argUuid uuid.UUID) (GetExerciseTranslationRow, error) {
	row := q.db.QueryRow(ctx, getExerciseTranslation, argUuid)
	var i GetExerciseTranslationRow
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.Uuid_2,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.Data,
	)
	return i, err
}

const updateExerciseTranslation = `-- name: UpdateExerciseTranslation :one
UPDATE "exercise_translations"
SET "name" = COALESCE($3, "name"),
    "description" = COALESCE($4, "description")
FROM "exercises"
WHERE "exercise_translations"."exercise_uuid" = "exercises"."uuid" AND "exercise_translations"."language" = $2
AND "exercises"."uuid" = $1
RETURNING exercise_translations.uuid, exercise_translations.exercise_uuid, exercise_translations.language, exercise_translations.name, exercise_translations.description
`

type UpdateExerciseTranslationParams struct {
	Uuid        uuid.UUID `json:"uuid"`
	Language    string    `json:"language"`
	Name        *string   `json:"name"`
	Description *string   `json:"description"`
}

func (q *Queries) UpdateExerciseTranslation(ctx context.Context, arg UpdateExerciseTranslationParams) (ExerciseTranslation, error) {
	row := q.db.QueryRow(ctx, updateExerciseTranslation,
		arg.Uuid,
		arg.Language,
		arg.Name,
		arg.Description,
	)
	var i ExerciseTranslation
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
	)
	return i, err
}
