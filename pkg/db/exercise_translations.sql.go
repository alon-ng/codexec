// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercise_translations.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createExerciseTranslation = `-- name: CreateExerciseTranslation :one
INSERT INTO "exercise_translations" (
  "exercise_uuid",
  "language",
  "name",
  "description",
  "code_data",
  "quiz_data"
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING uuid, exercise_uuid, language, name, description, code_data, quiz_data
`

type CreateExerciseTranslationParams struct {
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
}

func (q *Queries) CreateExerciseTranslation(ctx context.Context, arg CreateExerciseTranslationParams) (ExerciseTranslation, error) {
	row := q.db.QueryRow(ctx, createExerciseTranslation,
		arg.ExerciseUuid,
		arg.Language,
		arg.Name,
		arg.Description,
		arg.CodeData,
		arg.QuizData,
	)
	var i ExerciseTranslation
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.CodeData,
		&i.QuizData,
	)
	return i, err
}

const deleteExerciseTranslation = `-- name: DeleteExerciseTranslation :exec
DELETE FROM "exercise_translations"
USING "exercises"
WHERE "exercise_translations"."exercise_uuid" = "exercises"."uuid"
AND "exercises"."uuid" = $1
`

func (q *Queries) DeleteExerciseTranslation(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExerciseTranslation, argUuid)
	return err
}

const getExerciseTranslation = `-- name: GetExerciseTranslation :one
SELECT exercise_translations.uuid, exercise_uuid, language, name, description, exercise_translations.code_data, exercise_translations.quiz_data, exercises.uuid, created_at, modified_at, deleted_at, lesson_uuid, order_index, reward, type, exercises.code_data, exercises.quiz_data, io_checker, code_checker FROM "exercise_translations"
JOIN "exercises" ON "exercise_translations"."exercise_uuid" = "exercises"."uuid"
WHERE "exercise_translations"."uuid" = $1
AND "exercises"."deleted_at" IS NULL
LIMIT 1
`

type GetExerciseTranslationRow struct {
	Uuid         uuid.UUID        `json:"uuid"`
	ExerciseUuid uuid.UUID        `json:"exercise_uuid"`
	Language     string           `json:"language"`
	Name         string           `json:"name"`
	Description  string           `json:"description"`
	CodeData     *json.RawMessage `json:"code_data"`
	QuizData     *json.RawMessage `json:"quiz_data"`
	Uuid_2       uuid.UUID        `json:"uuid_2"`
	CreatedAt    time.Time        `json:"created_at"`
	ModifiedAt   time.Time        `json:"modified_at"`
	DeletedAt    *time.Time       `json:"deleted_at"`
	LessonUuid   uuid.UUID        `json:"lesson_uuid"`
	OrderIndex   int16            `json:"order_index"`
	Reward       int16            `json:"reward"`
	Type         ExerciseType     `json:"type"`
	CodeData_2   *json.RawMessage `json:"code_data_2"`
	QuizData_2   *json.RawMessage `json:"quiz_data_2"`
	IoChecker    *json.RawMessage `json:"io_checker"`
	CodeChecker  *json.RawMessage `json:"code_checker"`
}

func (q *Queries) GetExerciseTranslation(ctx context.Context, argUuid uuid.UUID) (GetExerciseTranslationRow, error) {
	row := q.db.QueryRow(ctx, getExerciseTranslation, argUuid)
	var i GetExerciseTranslationRow
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.CodeData,
		&i.QuizData,
		&i.Uuid_2,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.DeletedAt,
		&i.LessonUuid,
		&i.OrderIndex,
		&i.Reward,
		&i.Type,
		&i.CodeData_2,
		&i.QuizData_2,
		&i.IoChecker,
		&i.CodeChecker,
	)
	return i, err
}

const updateExerciseTranslation = `-- name: UpdateExerciseTranslation :one
UPDATE "exercise_translations"
SET "name" = COALESCE($3, "name"),
    "description" = COALESCE($4, "description"),
    "code_data" = COALESCE($5, "exercise_translations"."code_data"),
    "quiz_data" = COALESCE($6, "exercise_translations"."quiz_data")
FROM "exercises"
WHERE "exercise_translations"."exercise_uuid" = "exercises"."uuid" AND "exercise_translations"."language" = $2
AND "exercises"."uuid" = $1
RETURNING exercise_translations.uuid, exercise_translations.exercise_uuid, exercise_translations.language, exercise_translations.name, exercise_translations.description, exercise_translations.code_data, exercise_translations.quiz_data
`

type UpdateExerciseTranslationParams struct {
	Uuid        uuid.UUID        `json:"uuid"`
	Language    string           `json:"language"`
	Name        *string          `json:"name"`
	Description *string          `json:"description"`
	CodeData    *json.RawMessage `json:"code_data"`
	QuizData    *json.RawMessage `json:"quiz_data"`
}

func (q *Queries) UpdateExerciseTranslation(ctx context.Context, arg UpdateExerciseTranslationParams) (ExerciseTranslation, error) {
	row := q.db.QueryRow(ctx, updateExerciseTranslation,
		arg.Uuid,
		arg.Language,
		arg.Name,
		arg.Description,
		arg.CodeData,
		arg.QuizData,
	)
	var i ExerciseTranslation
	err := row.Scan(
		&i.Uuid,
		&i.ExerciseUuid,
		&i.Language,
		&i.Name,
		&i.Description,
		&i.CodeData,
		&i.QuizData,
	)
	return i, err
}
