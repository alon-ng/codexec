// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_courses.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUserCourse = `-- name: CreateUserCourse :one
INSERT INTO "user_courses" (
  "user_uuid", 
  "course_uuid", 
  "completed_at"
) VALUES (
  $1, $2, $3
) RETURNING uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at
`

type CreateUserCourseParams struct {
	UserUuid    uuid.UUID  `json:"user_uuid"`
	CourseUuid  uuid.UUID  `json:"course_uuid"`
	CompletedAt *time.Time `json:"completed_at"`
}

func (q *Queries) CreateUserCourse(ctx context.Context, arg CreateUserCourseParams) (UserCourse, error) {
	row := q.db.QueryRow(ctx, createUserCourse, arg.UserUuid, arg.CourseUuid, arg.CompletedAt)
	var i UserCourse
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.CourseUuid,
		&i.CompletedAt,
	)
	return i, err
}

const deleteUserCourse = `-- name: DeleteUserCourse :exec
DELETE FROM "user_courses"
WHERE "uuid" = $1
`

func (q *Queries) DeleteUserCourse(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserCourse, argUuid)
	return err
}

const initUserCourse = `-- name: InitUserCourse :one
WITH course_lessons AS (
    SELECT "uuid" AS "lesson_uuid"
    FROM "lessons"
    WHERE "lessons"."course_uuid" = $2
      AND "deleted_at" IS NULL
    ORDER BY "order_index" ASC
),
course_exercises AS (
    SELECT "uuid" AS "exercise_uuid"
    FROM "exercises"
    WHERE "lesson_uuid" IN (SELECT "lesson_uuid" FROM course_lessons)
      AND "deleted_at" IS NULL
    ORDER BY "order_index" ASC
),
inserted_user_course AS (
    INSERT INTO "user_courses" (
        "user_uuid",
        "course_uuid",
        "completed_at"
    ) VALUES (
        $1, $2, NULL
    )
    RETURNING uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at
),
inserted_user_lessons AS (
    INSERT INTO "user_lessons" (
        "user_uuid",
        "lesson_uuid",
        "completed_at"
    )
    SELECT $1, "lesson_uuid", NULL
    FROM course_lessons
    RETURNING uuid, started_at, last_accessed_at, user_uuid, lesson_uuid, completed_at
),
inserted_user_exercises AS (
    INSERT INTO "user_exercises" (
        "user_uuid",
        "exercise_uuid",
        "submission",
        "attempts",
        "completed_at"
    )
    SELECT $1, "exercise_uuid", '{}'::jsonb, 0, NULL
    FROM course_exercises
    RETURNING uuid, started_at, last_accessed_at, user_uuid, exercise_uuid, submission, attempts, completed_at
)
SELECT uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at FROM inserted_user_course
`

type InitUserCourseParams struct {
	UserUuid   uuid.UUID `json:"user_uuid"`
	CourseUuid uuid.UUID `json:"course_uuid"`
}

type InitUserCourseRow struct {
	Uuid           uuid.UUID  `json:"uuid"`
	StartedAt      time.Time  `json:"started_at"`
	LastAccessedAt *time.Time `json:"last_accessed_at"`
	UserUuid       uuid.UUID  `json:"user_uuid"`
	CourseUuid     uuid.UUID  `json:"course_uuid"`
	CompletedAt    *time.Time `json:"completed_at"`
}

func (q *Queries) InitUserCourse(ctx context.Context, arg InitUserCourseParams) (InitUserCourseRow, error) {
	row := q.db.QueryRow(ctx, initUserCourse, arg.UserUuid, arg.CourseUuid)
	var i InitUserCourseRow
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.CourseUuid,
		&i.CompletedAt,
	)
	return i, err
}

const listUserCoursesWithProgress = `-- name: ListUserCoursesWithProgress :many
WITH course_exercise_counts AS (
    SELECT 
        lessons.course_uuid,
        COUNT(exercises.uuid)::BIGINT AS total_exercises
    FROM lessons
    JOIN exercises ON lessons.uuid = exercises.lesson_uuid
    WHERE lessons.deleted_at IS NULL
      AND exercises.deleted_at IS NULL
    GROUP BY lessons.course_uuid
),
user_exercise_counts AS (
    SELECT 
        lessons.course_uuid,
        user_exercises.user_uuid,
        COUNT(user_exercises.uuid)::BIGINT AS completed_exercises
    FROM lessons
    JOIN exercises ON lessons.uuid = exercises.lesson_uuid
    JOIN user_exercises ON exercises.uuid = user_exercises.exercise_uuid
    WHERE lessons.deleted_at IS NULL
      AND exercises.deleted_at IS NULL
      AND user_exercises.completed_at IS NOT NULL
    GROUP BY lessons.course_uuid, user_exercises.user_uuid
),
next_lessons AS (
    SELECT DISTINCT ON (lessons.course_uuid)
        lessons.course_uuid,
        lessons.uuid AS lesson_uuid,
        lesson_translations.name AS lesson_name
    FROM lessons
    LEFT JOIN user_lessons ON lessons.uuid = user_lessons.lesson_uuid AND user_lessons.user_uuid = $1
    LEFT JOIN lesson_translations ON lessons.uuid = lesson_translations.lesson_uuid AND lesson_translations.language = $2
    WHERE lessons.deleted_at IS NULL
      AND (user_lessons.completed_at IS NULL OR user_lessons.uuid IS NULL)
    ORDER BY lessons.course_uuid, lessons.order_index ASC
),
next_exercises AS (
    SELECT DISTINCT ON (lessons.course_uuid)
        lessons.course_uuid,
        exercises.uuid AS exercise_uuid,
        exercise_translations.name AS exercise_name,
        lessons.uuid AS lesson_uuid,
        lesson_translations.name AS lesson_name
    FROM lessons
    JOIN exercises ON lessons.uuid = exercises.lesson_uuid
    LEFT JOIN user_exercises ON exercises.uuid = user_exercises.exercise_uuid AND user_exercises.user_uuid = $1
    LEFT JOIN exercise_translations ON exercises.uuid = exercise_translations.exercise_uuid AND exercise_translations.language = $2
    LEFT JOIN lesson_translations ON lessons.uuid = lesson_translations.lesson_uuid AND lesson_translations.language = $2
    WHERE lessons.deleted_at IS NULL
      AND exercises.deleted_at IS NULL
      AND (user_exercises.completed_at IS NULL OR user_exercises.uuid IS NULL)
    ORDER BY lessons.course_uuid, lessons.order_index ASC, exercises.order_index ASC
)
SELECT  courses.uuid                        AS "course_uuid", 
        courses.created_at                  AS "course_created_at", 
        courses.modified_at                 AS "course_modified_at", 
        courses.deleted_at                  AS "course_deleted_at", 
        courses.subject                     AS "course_subject", 
        courses.price                       AS "course_price", 
        courses.discount                    AS "course_discount", 
        courses.is_active                   AS "course_is_active", 
        courses.difficulty                  AS "course_difficulty",
        course_translations.uuid            AS "course_translation_uuid",
        course_translations.language        AS "course_translation_language",
        course_translations.name            AS "course_name", 
        course_translations.description     AS "course_description", 
        course_translations.bullets         AS "course_bullets", 
        user_courses.started_at             AS "user_course_started_at",
        user_courses.last_accessed_at       AS "user_course_last_accessed_at",
        user_courses.completed_at           AS "user_course_completed_at",
        COALESCE(course_exercise_counts.total_exercises, 0)::INTEGER   AS total_exercises,
        COALESCE(user_exercise_counts.completed_exercises, 0)::INTEGER AS completed_exercises,
        next_lessons.lesson_uuid            AS "next_lesson_uuid",
        next_lessons.lesson_name            AS "next_lesson_name",
        next_exercises.exercise_uuid        AS "next_exercise_uuid",
        next_exercises.exercise_name        AS "next_exercise_name"
FROM "user_courses"
JOIN "courses"                    ON "user_courses"."course_uuid" = "courses"."uuid" AND "courses"."deleted_at" IS NULL
JOIN "course_translations"        ON "courses"."uuid" = "course_translations"."course_uuid" AND "course_translations"."language" = $2
LEFT JOIN course_exercise_counts  ON "courses"."uuid" = course_exercise_counts.course_uuid
LEFT JOIN user_exercise_counts    ON "courses"."uuid" = user_exercise_counts.course_uuid AND "user_courses"."user_uuid" = user_exercise_counts.user_uuid
LEFT JOIN next_lessons            ON "courses"."uuid" = next_lessons.course_uuid
LEFT JOIN next_exercises          ON "courses"."uuid" = next_exercises.course_uuid
WHERE "user_courses"."user_uuid" = $1
AND   ($5::uuid IS NULL OR "courses"."uuid" = $5)
AND   ($6::text IS NULL OR "courses"."subject" = $6)
AND   ($7::boolean IS NULL OR "courses"."is_active" = $7)
ORDER BY "user_courses"."last_accessed_at" DESC
LIMIT $3 OFFSET $4
`

type ListUserCoursesWithProgressParams struct {
	UserUuid   uuid.UUID  `json:"user_uuid"`
	Language   string     `json:"language"`
	Limit      int32      `json:"limit"`
	Offset     int32      `json:"offset"`
	CourseUuid *uuid.UUID `json:"course_uuid"`
	Subject    *string    `json:"subject"`
	IsActive   *bool      `json:"is_active"`
}

type ListUserCoursesWithProgressRow struct {
	CourseUuid                uuid.UUID  `json:"course_uuid"`
	CourseCreatedAt           time.Time  `json:"course_created_at"`
	CourseModifiedAt          time.Time  `json:"course_modified_at"`
	CourseDeletedAt           *time.Time `json:"course_deleted_at"`
	CourseSubject             string     `json:"course_subject"`
	CoursePrice               int16      `json:"course_price"`
	CourseDiscount            int16      `json:"course_discount"`
	CourseIsActive            bool       `json:"course_is_active"`
	CourseDifficulty          int16      `json:"course_difficulty"`
	CourseTranslationUuid     uuid.UUID  `json:"course_translation_uuid"`
	CourseTranslationLanguage string     `json:"course_translation_language"`
	CourseName                string     `json:"course_name"`
	CourseDescription         string     `json:"course_description"`
	CourseBullets             string     `json:"course_bullets"`
	UserCourseStartedAt       time.Time  `json:"user_course_started_at"`
	UserCourseLastAccessedAt  *time.Time `json:"user_course_last_accessed_at"`
	UserCourseCompletedAt     *time.Time `json:"user_course_completed_at"`
	TotalExercises            int32      `json:"total_exercises"`
	CompletedExercises        int32      `json:"completed_exercises"`
	NextLessonUuid            *uuid.UUID `json:"next_lesson_uuid"`
	NextLessonName            *string    `json:"next_lesson_name"`
	NextExerciseUuid          *uuid.UUID `json:"next_exercise_uuid"`
	NextExerciseName          *string    `json:"next_exercise_name"`
}

func (q *Queries) ListUserCoursesWithProgress(ctx context.Context, arg ListUserCoursesWithProgressParams) ([]ListUserCoursesWithProgressRow, error) {
	rows, err := q.db.Query(ctx, listUserCoursesWithProgress,
		arg.UserUuid,
		arg.Language,
		arg.Limit,
		arg.Offset,
		arg.CourseUuid,
		arg.Subject,
		arg.IsActive,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserCoursesWithProgressRow{}
	for rows.Next() {
		var i ListUserCoursesWithProgressRow
		if err := rows.Scan(
			&i.CourseUuid,
			&i.CourseCreatedAt,
			&i.CourseModifiedAt,
			&i.CourseDeletedAt,
			&i.CourseSubject,
			&i.CoursePrice,
			&i.CourseDiscount,
			&i.CourseIsActive,
			&i.CourseDifficulty,
			&i.CourseTranslationUuid,
			&i.CourseTranslationLanguage,
			&i.CourseName,
			&i.CourseDescription,
			&i.CourseBullets,
			&i.UserCourseStartedAt,
			&i.UserCourseLastAccessedAt,
			&i.UserCourseCompletedAt,
			&i.TotalExercises,
			&i.CompletedExercises,
			&i.NextLessonUuid,
			&i.NextLessonName,
			&i.NextExerciseUuid,
			&i.NextExerciseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncProgressAfterExercise = `-- name: SyncProgressAfterExercise :exec
WITH target AS (
    SELECT e.lesson_uuid, l.course_uuid
    FROM exercises e
    JOIN lessons l ON e.lesson_uuid = l.uuid
    WHERE e.uuid = $2
),
lesson_progress AS (
    SELECT 
        t.lesson_uuid,
        BOOL_AND(ue.completed_at IS NOT NULL) as is_completed
    FROM target t
    JOIN exercises e ON t.lesson_uuid = e.lesson_uuid
    LEFT JOIN user_exercises ue ON e.uuid = ue.exercise_uuid AND ue.user_uuid = $1
    WHERE e.deleted_at IS NULL
    GROUP BY t.lesson_uuid
),
course_progress AS (
    SELECT 
        t.course_uuid,
        BOOL_AND(ue.completed_at IS NOT NULL) as is_completed
    FROM target t
    JOIN lessons l ON t.course_uuid = l.course_uuid
    JOIN exercises e ON l.uuid = e.lesson_uuid
    LEFT JOIN user_exercises ue ON e.uuid = ue.exercise_uuid AND ue.user_uuid = $1
    WHERE l.deleted_at IS NULL AND e.deleted_at IS NULL
    GROUP BY t.course_uuid
),
update_lesson AS (
    UPDATE user_lessons
    SET completed_at = NOW()
    FROM lesson_progress
    WHERE user_lessons.lesson_uuid = lesson_progress.lesson_uuid
      AND user_lessons.user_uuid = $1
      AND lesson_progress.is_completed
      AND user_lessons.completed_at IS NULL
)
UPDATE user_courses
SET completed_at = NOW()
FROM course_progress
WHERE user_courses.course_uuid = course_progress.course_uuid
  AND user_courses.user_uuid = $1
  AND course_progress.is_completed
  AND user_courses.completed_at IS NULL
`

type SyncProgressAfterExerciseParams struct {
	UserUuid     uuid.UUID `json:"user_uuid"`
	ExerciseUuid uuid.UUID `json:"exercise_uuid"`
}

func (q *Queries) SyncProgressAfterExercise(ctx context.Context, arg SyncProgressAfterExerciseParams) error {
	_, err := q.db.Exec(ctx, syncProgressAfterExercise, arg.UserUuid, arg.ExerciseUuid)
	return err
}

const updateUserCourse = `-- name: UpdateUserCourse :one
UPDATE "user_courses"
SET "user_uuid" = COALESCE($2, "user_uuid"), 
    "course_uuid" = COALESCE($3, "course_uuid"), 
    "completed_at" = COALESCE($4, "completed_at")
WHERE "uuid" = $1
RETURNING uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at
`

type UpdateUserCourseParams struct {
	Uuid        uuid.UUID  `json:"uuid"`
	UserUuid    *uuid.UUID `json:"user_uuid"`
	CourseUuid  *uuid.UUID `json:"course_uuid"`
	CompletedAt *time.Time `json:"completed_at"`
}

func (q *Queries) UpdateUserCourse(ctx context.Context, arg UpdateUserCourseParams) (UserCourse, error) {
	row := q.db.QueryRow(ctx, updateUserCourse,
		arg.Uuid,
		arg.UserUuid,
		arg.CourseUuid,
		arg.CompletedAt,
	)
	var i UserCourse
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.CourseUuid,
		&i.CompletedAt,
	)
	return i, err
}

const getUserCourseFull = `-- name: getUserCourseFull :many
SELECT  courses.uuid            AS "course_uuid", 
        user_courses.uuid       AS "user_course_uuid",
        user_courses.started_at AS "user_course_started_at",
        user_courses.last_accessed_at AS "user_course_last_accessed_at",
        (user_courses.completed_at IS NOT NULL)::boolean AS "course_is_completed",
        user_courses.completed_at AS "course_completed_at",
        lessons.uuid            AS "lesson_uuid", 
        user_lessons.uuid       AS "user_lesson_uuid",
        user_lessons.started_at AS "user_lesson_started_at",
        user_lessons.last_accessed_at AS "user_lesson_last_accessed_at",
        (user_lessons.completed_at IS NOT NULL)::boolean AS "lesson_is_completed",
        user_lessons.completed_at AS "lesson_completed_at",
        exercises.uuid          AS "exercise_uuid", 
        user_exercises.uuid     AS "user_exercise_uuid",
        user_exercises.started_at AS "user_exercise_started_at",
        user_exercises.last_accessed_at AS "user_exercise_last_accessed_at",
        (user_exercises.completed_at IS NOT NULL)::boolean AS "exercise_is_completed",
        user_exercises.completed_at AS "exercise_completed_at"
FROM "courses"
LEFT JOIN "lessons"   ON "courses"."uuid" = "lessons"."course_uuid"   AND "lessons"."deleted_at" IS NULL
LEFT JOIN "exercises" ON "lessons"."uuid" = "exercises"."lesson_uuid" AND "exercises"."deleted_at" IS NULL
LEFT JOIN "user_courses" ON "courses"."uuid" = "user_courses"."course_uuid" AND "user_courses"."user_uuid" = $1
LEFT JOIN "user_lessons" ON "lessons"."uuid" = "user_lessons"."lesson_uuid" AND "user_lessons"."user_uuid" = $1
LEFT JOIN "user_exercises" ON "exercises"."uuid" = "user_exercises"."exercise_uuid" AND "user_exercises"."user_uuid" = $1
WHERE "courses"."uuid" = $2 AND "courses"."deleted_at" IS NULL
ORDER BY "lessons"."order_index" ASC, "exercises"."order_index" ASC
`

type getUserCourseFullParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	Uuid     uuid.UUID `json:"uuid"`
}

type getUserCourseFullRow struct {
	CourseUuid                 uuid.UUID  `json:"course_uuid"`
	UserCourseUuid             *uuid.UUID `json:"user_course_uuid"`
	UserCourseStartedAt        *time.Time `json:"user_course_started_at"`
	UserCourseLastAccessedAt   *time.Time `json:"user_course_last_accessed_at"`
	CourseIsCompleted          bool       `json:"course_is_completed"`
	CourseCompletedAt          *time.Time `json:"course_completed_at"`
	LessonUuid                 *uuid.UUID `json:"lesson_uuid"`
	UserLessonUuid             *uuid.UUID `json:"user_lesson_uuid"`
	UserLessonStartedAt        *time.Time `json:"user_lesson_started_at"`
	UserLessonLastAccessedAt   *time.Time `json:"user_lesson_last_accessed_at"`
	LessonIsCompleted          bool       `json:"lesson_is_completed"`
	LessonCompletedAt          *time.Time `json:"lesson_completed_at"`
	ExerciseUuid               *uuid.UUID `json:"exercise_uuid"`
	UserExerciseUuid           *uuid.UUID `json:"user_exercise_uuid"`
	UserExerciseStartedAt      *time.Time `json:"user_exercise_started_at"`
	UserExerciseLastAccessedAt *time.Time `json:"user_exercise_last_accessed_at"`
	ExerciseIsCompleted        bool       `json:"exercise_is_completed"`
	ExerciseCompletedAt        *time.Time `json:"exercise_completed_at"`
}

func (q *Queries) getUserCourseFull(ctx context.Context, arg getUserCourseFullParams) ([]getUserCourseFullRow, error) {
	rows, err := q.db.Query(ctx, getUserCourseFull, arg.UserUuid, arg.Uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []getUserCourseFullRow{}
	for rows.Next() {
		var i getUserCourseFullRow
		if err := rows.Scan(
			&i.CourseUuid,
			&i.UserCourseUuid,
			&i.UserCourseStartedAt,
			&i.UserCourseLastAccessedAt,
			&i.CourseIsCompleted,
			&i.CourseCompletedAt,
			&i.LessonUuid,
			&i.UserLessonUuid,
			&i.UserLessonStartedAt,
			&i.UserLessonLastAccessedAt,
			&i.LessonIsCompleted,
			&i.LessonCompletedAt,
			&i.ExerciseUuid,
			&i.UserExerciseUuid,
			&i.UserExerciseStartedAt,
			&i.UserExerciseLastAccessedAt,
			&i.ExerciseIsCompleted,
			&i.ExerciseCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
