// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_courses.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUserCourse = `-- name: CreateUserCourse :one
INSERT INTO "user_courses" (
  "user_uuid", 
  "course_uuid", 
  "completed_at"
) VALUES (
  $1, $2, $3
) RETURNING uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at
`

type CreateUserCourseParams struct {
	UserUuid    uuid.UUID  `json:"user_uuid"`
	CourseUuid  uuid.UUID  `json:"course_uuid"`
	CompletedAt *time.Time `json:"completed_at"`
}

func (q *Queries) CreateUserCourse(ctx context.Context, arg CreateUserCourseParams) (UserCourse, error) {
	row := q.db.QueryRow(ctx, createUserCourse, arg.UserUuid, arg.CourseUuid, arg.CompletedAt)
	var i UserCourse
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.CourseUuid,
		&i.CompletedAt,
	)
	return i, err
}

const deleteUserCourse = `-- name: DeleteUserCourse :exec
DELETE FROM "user_courses"
WHERE "uuid" = $1
`

func (q *Queries) DeleteUserCourse(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserCourse, argUuid)
	return err
}

const updateUserCourse = `-- name: UpdateUserCourse :one
UPDATE "user_courses"
SET "user_uuid" = COALESCE($2, "user_uuid"), 
    "course_uuid" = COALESCE($3, "course_uuid"), 
    "completed_at" = COALESCE($4, "completed_at")
WHERE "uuid" = $1
RETURNING uuid, started_at, last_accessed_at, user_uuid, course_uuid, completed_at
`

type UpdateUserCourseParams struct {
	Uuid        uuid.UUID  `json:"uuid"`
	UserUuid    uuid.UUID  `json:"user_uuid"`
	CourseUuid  uuid.UUID  `json:"course_uuid"`
	CompletedAt *time.Time `json:"completed_at"`
}

func (q *Queries) UpdateUserCourse(ctx context.Context, arg UpdateUserCourseParams) (UserCourse, error) {
	row := q.db.QueryRow(ctx, updateUserCourse,
		arg.Uuid,
		arg.UserUuid,
		arg.CourseUuid,
		arg.CompletedAt,
	)
	var i UserCourse
	err := row.Scan(
		&i.Uuid,
		&i.StartedAt,
		&i.LastAccessedAt,
		&i.UserUuid,
		&i.CourseUuid,
		&i.CompletedAt,
	)
	return i, err
}

const getUserCourseFull = `-- name: getUserCourseFull :many
SELECT  courses.uuid            AS "course_uuid", 
        user_courses.uuid       AS "user_course_uuid",
        user_courses.started_at AS "user_course_started_at",
        user_courses.last_accessed_at AS "user_course_last_accessed_at",
        (user_courses.completed_at IS NOT NULL)::boolean AS "course_is_completed",
        user_courses.completed_at AS "course_completed_at",
        lessons.uuid            AS "lesson_uuid", 
        user_lessons.uuid       AS "user_lesson_uuid",
        user_lessons.started_at AS "user_lesson_started_at",
        user_lessons.last_accessed_at AS "user_lesson_last_accessed_at",
        (user_lessons.completed_at IS NOT NULL)::boolean AS "lesson_is_completed",
        user_lessons.completed_at AS "lesson_completed_at",
        exercises.uuid          AS "exercise_uuid", 
        user_exercises.uuid     AS "user_exercise_uuid",
        user_exercises.started_at AS "user_exercise_started_at",
        user_exercises.last_accessed_at AS "user_exercise_last_accessed_at",
        (user_exercises.completed_at IS NOT NULL)::boolean AS "exercise_is_completed",
        user_exercises.completed_at AS "exercise_completed_at"
FROM "courses"
LEFT JOIN "lessons"   ON "courses"."uuid" = "lessons"."course_uuid"   AND "lessons"."deleted_at" IS NULL
LEFT JOIN "exercises" ON "lessons"."uuid" = "exercises"."lesson_uuid" AND "exercises"."deleted_at" IS NULL
LEFT JOIN "user_courses" ON "courses"."uuid" = "user_courses"."course_uuid" AND "user_courses"."user_uuid" = $1
LEFT JOIN "user_lessons" ON "lessons"."uuid" = "user_lessons"."lesson_uuid" AND "user_lessons"."user_uuid" = $1
LEFT JOIN "user_exercises" ON "exercises"."uuid" = "user_exercises"."exercise_uuid" AND "user_exercises"."user_uuid" = $1
WHERE "courses"."uuid" = $2 AND "courses"."deleted_at" IS NULL
ORDER BY "lessons"."order_index" ASC, "exercises"."order_index" ASC
`

type getUserCourseFullParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	Uuid     uuid.UUID `json:"uuid"`
}

type getUserCourseFullRow struct {
	CourseUuid                 uuid.UUID  `json:"course_uuid"`
	UserCourseUuid             *uuid.UUID `json:"user_course_uuid"`
	UserCourseStartedAt        *time.Time `json:"user_course_started_at"`
	UserCourseLastAccessedAt   *time.Time `json:"user_course_last_accessed_at"`
	CourseIsCompleted          bool       `json:"course_is_completed"`
	CourseCompletedAt          *time.Time `json:"course_completed_at"`
	LessonUuid                 *uuid.UUID `json:"lesson_uuid"`
	UserLessonUuid             *uuid.UUID `json:"user_lesson_uuid"`
	UserLessonStartedAt        *time.Time `json:"user_lesson_started_at"`
	UserLessonLastAccessedAt   *time.Time `json:"user_lesson_last_accessed_at"`
	LessonIsCompleted          bool       `json:"lesson_is_completed"`
	LessonCompletedAt          *time.Time `json:"lesson_completed_at"`
	ExerciseUuid               *uuid.UUID `json:"exercise_uuid"`
	UserExerciseUuid           *uuid.UUID `json:"user_exercise_uuid"`
	UserExerciseStartedAt      *time.Time `json:"user_exercise_started_at"`
	UserExerciseLastAccessedAt *time.Time `json:"user_exercise_last_accessed_at"`
	ExerciseIsCompleted        bool       `json:"exercise_is_completed"`
	ExerciseCompletedAt        *time.Time `json:"exercise_completed_at"`
}

func (q *Queries) getUserCourseFull(ctx context.Context, arg getUserCourseFullParams) ([]getUserCourseFullRow, error) {
	rows, err := q.db.Query(ctx, getUserCourseFull, arg.UserUuid, arg.Uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []getUserCourseFullRow{}
	for rows.Next() {
		var i getUserCourseFullRow
		if err := rows.Scan(
			&i.CourseUuid,
			&i.UserCourseUuid,
			&i.UserCourseStartedAt,
			&i.UserCourseLastAccessedAt,
			&i.CourseIsCompleted,
			&i.CourseCompletedAt,
			&i.LessonUuid,
			&i.UserLessonUuid,
			&i.UserLessonStartedAt,
			&i.UserLessonLastAccessedAt,
			&i.LessonIsCompleted,
			&i.LessonCompletedAt,
			&i.ExerciseUuid,
			&i.UserExerciseUuid,
			&i.UserExerciseStartedAt,
			&i.UserExerciseLastAccessedAt,
			&i.ExerciseIsCompleted,
			&i.ExerciseCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
